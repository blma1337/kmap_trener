<!DOCTYPE html>
<html lang="cs">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Karnaughova Mapa - Kompletn√≠ Tren√©r</title>
    <style>
        :root {
            --bg-color: #1a1a1a;
            --panel-bg: #262626;
            --text-color: #eee;
            --accent: #FF7043; 
            --accent-hover: #D84315;
            --secondary-btn: #5d4037; 
            --hint-btn: #FDD835; 
            --hint-text: #212121;
            --error: #ef5350;
            --success: #66bb6a;
            --grid-border: #555;
            --cell-size: 60px;
        }

        body {
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
        }

        h1, h2, h3 { margin: 0 0 15px 0; color: var(--accent); }
        
        /* Layout */
        .main-container {
            display: flex;
            flex-wrap: wrap;
            gap: 30px;
            justify-content: center;
            width: 100%;
            max-width: 1400px;
            align-items: flex-start;
        }

        .panel {
            background: var(--panel-bg);
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.5);
            flex: 1;
            min-width: 380px;
            border-top: 4px solid var(--accent);
            position: relative;
        }

        .controls {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            align-items: center;
            flex-wrap: wrap;
            background: #333;
            padding: 15px;
            border-radius: 8px;
            width: 100%;
            max-width: 1000px;
            justify-content: center;
        }

        button {
            background-color: var(--accent);
            color: #000;
            border: none;
            padding: 10px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            transition: 0.2s;
            text-transform: uppercase;
            font-size: 0.85rem;
        }
        button:hover { background-color: var(--accent-hover); color: white; }
        button:disabled { background-color: #444; color: #888; cursor: not-allowed; }
        
        button.secondary { background-color: var(--secondary-btn); color: #ddd; }
        button.secondary:hover { background-color: #4e342e; }
        button.success { background-color: var(--success); color: white; }
        button.hint-btn { background-color: var(--hint-btn); color: var(--hint-text); }
        
        button.eye-btn {
            padding: 2px 6px; font-size: 1rem; background: transparent; border: 1px solid #555; color: #aaa;
        }
        button.eye-btn:hover { background: #444; color: white; }

        select, input[type="text"] {
            padding: 10px; background: #222; color: white; border: 1px solid #555; border-radius: 4px;
        }

        /* Truth Table */
        .truth-table-container {
            max-height: 500px; overflow-y: auto; border: 1px solid #444;
        }
        table.truth-table { width: 100%; border-collapse: collapse; font-size: 0.9rem; text-align: center; }
        table.truth-table th { background: #333; position: sticky; top: 0; padding: 8px; color: var(--accent); }
        table.truth-table td { border-bottom: 1px solid #444; padding: 4px; }
        table.truth-table tr.active-row { background: rgba(255, 112, 67, 0.15); border: 1px solid var(--accent); }
        
        .output-cell {
            background: #444; color: white; cursor: pointer; font-weight: bold; width: 40px; border: 1px solid #666; transition: 0.2s;
        }
        .output-cell:hover { background: #555; }
        .output-cell.is-1 { color: var(--success); }
        .output-cell.is-0 { color: var(--error); }

        /* K-Map */
        .map-container-relative {
            position: relative; display: inline-block; margin: 30px;
            padding: 40px; /* Space for lines */
        }

        table.kmap { border-collapse: collapse; margin: 0; background: #1e1e1e; }
        table.kmap td {
            width: var(--cell-size); height: var(--cell-size);
            border: 1px solid var(--grid-border);
            text-align: center; font-size: 1.3rem;
            cursor: pointer; position: relative; z-index: 2;
            transition: all 0.3s ease;
            box-sizing: border-box; 
        }
        table.kmap td[data-val="1"] { color: white; font-weight: bold; }
        table.kmap td[data-val="0"] { color: #555; }
        
        table.kmap td.selected {
            background-color: rgba(255, 112, 67, 0.2);
            box-shadow: inset 0 0 0 2px var(--accent);
        }

        /* ANIMATION STATES */
        table.kmap td.dimmed { opacity: 0.1; filter: grayscale(100%); }
        
        table.kmap td.zone-valid { 
            background-color: rgba(76, 175, 80, 0.4) !important; 
            box-shadow: inset 0 0 0 3px #4CAF50;
            opacity: 1 !important; filter: none !important;
        }
        table.kmap td.zone-invalid { 
            background-color: rgba(244, 67, 54, 0.4) !important; 
            box-shadow: inset 0 0 0 3px #F44336;
            opacity: 1 !important; filter: none !important;
        }
        
        table.kmap td.target-pulse { 
            animation: pulseTarget 1s infinite; 
            background-color: rgba(255, 193, 7, 0.4) !important; 
            border: 2px solid #FFC107; 
            opacity: 1 !important; filter: none !important;
        }

        @keyframes pulseTarget { 0% { transform: scale(1); } 50% { transform: scale(1.15); } 100% { transform: scale(1); } }

        /* Coleman Lines (Restored Style v4 - Solid Bars) */
        .var-line {
            position: absolute;
            background-color: var(--text-color);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.9rem;
            font-weight: bold;
            z-index: 10;
        }
        .line-horizontal { height: 2px; border-left: 2px solid var(--text-color); border-right: 2px solid var(--text-color); }
        .line-vertical { width: 2px; border-top: 2px solid var(--text-color); border-bottom: 2px solid var(--text-color); }
        
        .line-label {
            position: absolute;
            background: var(--bg-color);
            padding: 0 4px;
            color: var(--text-color);
        }

        /* UI Elements */
        .instruction { color: #aaa; margin-bottom: 10px; font-style: italic; font-size: 0.9rem; }
        .status-msg { margin-top: 5px; padding: 10px; border-radius: 4px; font-size: 0.9rem; display: none; }
        .error-text { color: #ffab91; background: rgba(255, 0, 0, 0.15); border-left: 4px solid var(--error); }
        .success-text { color: #a5d6a7; background: rgba(0, 255, 0, 0.15); border-left: 4px solid var(--success); }
        .hint-text { color: #FFF59D; background: rgba(253, 216, 53, 0.15); border-left: 4px solid #FDD835; }
        
        .anim-controls {
            background: #222; padding: 10px; border-radius: 8px; border: 1px solid var(--accent);
            margin-top: 15px; display: none; text-align: center; max-width: 400px; margin-left: auto; margin-right: auto;
        }
        .anim-step-text { color: #fff; margin-bottom: 10px; min-height: 1.2em; font-size: 0.95rem; }

        .group-list { list-style: none; padding: 0; }
        .group-item { background: #333; margin-bottom: 10px; padding: 10px; border-radius: 4px; border-left: 5px solid gray; }
        .var-toggles { display: flex; gap: 5px; margin-top: 5px; flex-wrap: wrap; }
        .var-btn { width: 36px; height: 36px; border: 1px solid #555; background: #222; cursor: pointer; display: flex; flex-direction: column; align-items: center; justify-content: center; border-radius: 3px; }
        .var-btn.s-1 { border-color: var(--success); } .var-btn.s-1 span.v { color: var(--success); }
        .var-btn.s-0 { border-color: var(--error); } .var-btn.s-0 span.v { color: var(--error); }
        .group-indicator { position: absolute; pointer-events: none; border-radius: 4px; box-shadow: 0 0 2px rgba(0,0,0,0.5); }
        
        .custom-input-group {
            display: flex; gap: 5px; align-items: center; background: #222; padding: 5px 10px; border-radius: 4px; border: 1px solid #555;
        }
    </style>
</head>
<body>

    <h1>Karnaughova Mapa: Kompletn√≠ Trena≈æ√©r</h1>

    <div class="controls">
        <label>Poƒçet promƒõnn√Ωch:</label>
        <select id="varCountSelect" onchange="resetApp()">
            <option value="2">2 (A, B)</option>
            <option value="3">3 (A, B, C)</option>
            <option value="4" selected>4 (A, B, C, D)</option>
        </select>
        
        <label style="margin-left:15px;">Minimalizujeme:</label>
        <select id="solveModeSelect" onchange="resetApp()">
            <option value="minterm">Mintermy (1)</option>
            <option value="maxterm">Maxtermy (0)</option>
        </select>
        
        <div style="flex-grow:1"></div>
        
        <div class="custom-input-group">
            <input type="text" id="customIndices" placeholder="Nap≈ô. 0, 2, 5, 8" style="width: 150px; font-size:0.8rem;">
            <button onclick="applyCustomIndices()" style="padding: 8px 12px; font-size:0.75rem;">Pou≈æ√≠t vlastn√≠</button>
        </div>
        
        <button onclick="generateNewTask()" style="margin-left:10px;">üé≤ Nov√© Zad√°n√≠</button>
    </div>

    <div class="main-container">
        
        <!-- PANEL 1: Zad√°n√≠ & Tabulka -->
        <div class="panel" style="flex: 0 0 320px;">
            <h3>1. Pravdivostn√≠ Tabulka</h3>
            <p class="instruction" id="taskDesc">Vypl≈à sloupec Y (0/1) podle zad√°n√≠.</p>
            
            <div style="background:#222; padding:10px; border:1px solid #444; margin-bottom:10px; border-radius:4px;">
                <span style="color:#aaa; font-size:0.8rem;">Zad√°n√≠ (Indexy):</span><br>
                <strong id="taskIndices" style="color:var(--accent); font-family:monospace;">-</strong>
            </div>

            <div class="truth-table-container">
                <table class="truth-table" id="truthTable"></table>
            </div>
            
            <div style="margin-top:15px;">
                <button id="btnCheckTable" onclick="checkTable()" style="width:100%">Zkontrolovat tabulku</button>
                <div id="tableMsg" class="status-msg"></div>
            </div>

            <!-- Skip Button Moved Here -->
            <div style="margin-top: 20px; border-top: 1px solid #444; padding-top: 15px;">
                 <button onclick="skipToSolver()" style="width:100%; background:transparent; border:1px dashed #666; color:#888; font-size:0.8rem;">‚è© P≈ôeskoƒçit vypl≈àov√°n√≠ (Vyplnit za mƒõ)</button>
            </div>
        </div>

        <!-- PANEL 2: Mapa -->
        <div class="panel" id="mapPanel" style="opacity: 0.5; pointer-events: none;">
            <h3>2. Karnaughova Mapa</h3>
            <p class="instruction">
                P≈ôepi≈° hodnoty z tabulky do mapy. 
                <br><em>Tip: Pou≈æij "oko" v tabulce pro n√°povƒõdu.</em>
            </p>
            
            <div style="text-align:center;">
                <div class="map-container-relative" id="mapWrapper">
                    <div id="mapContainer"></div>
                </div>
                
                <!-- Interactive Animation Panel -->
                <div id="animPanel" class="anim-controls">
                    <div id="animText" class="anim-step-text">P≈ôipraven k eliminaci...</div>
                    <button id="animNextBtn" onclick="nextAnimStep()" style="background-color:#4CAF50; color:white;">Dal≈°√≠ krok &rarr;</button>
                    <button class="secondary" onclick="stopAnimation()" style="font-size:0.8rem; margin-left:10px;">Zru≈°it</button>
                </div>
            </div>
            
            <button id="btnCheckMap" onclick="checkMapAndUnlock()" style="width:100%; margin-top:20px;">Zkontrolovat p≈ôepis do mapy</button>
            <div id="mapMsg" class="status-msg"></div>
        </div>

        <!-- PANEL 3: Minimalizace -->
        <div class="panel" id="solvePanel" style="opacity: 0.5; pointer-events: none;">
            <div style="display:flex; justify-content:space-between; align-items:center;">
                <h3>3. Minimalizace</h3>
                <button class="hint-btn" onclick="showSmartHint()">üí° N√°povƒõda</button>
            </div>
            
            <p class="instruction" id="solveInst">...</p>
            
            <div style="display:flex; gap:10px; margin-bottom: 10px;">
                <button class="secondary" onclick="createGroupFromSelection()">‚ûï P≈ôidat skupinu</button>
                <button class="secondary" onclick="clearSelection()" style="background:#444">Zru≈°it v√Ωbƒõr</button>
            </div>

            <div id="hintBox" class="status-msg hint-text"></div>
            <div id="groupError" class="status-msg error-text"></div>

            <ul id="groupsList" class="group-list"></ul>

            <div style="margin-top: 20px; border-top: 1px solid #444; padding-top:15px;">
                <div style="font-family:monospace; background:#111; padding:10px; color:var(--accent); font-size:1.2rem; margin-bottom:10px;" id="finalEquation">Y = ...</div>
                <button class="success" onclick="checkFinalResult()">üèÜ Fin√°ln√≠ kontrola</button>
                <div id="finalStatus" class="status-msg"></div>
            </div>
        </div>

    </div>

    <script>
        // --- CONFIG ---
        const colors = ['#FF5722', '#FFC107', '#8BC34A', '#E040FB', '#00BCD4', '#f44336', '#3f51b5', '#cddc39'];
        const grayCodes = { 1: [0, 1], 2: [0, 1, 3, 2] };

        // --- STATE ---
        let state = {
            vars: 4,
            solveMode: 'minterm', 
            taskIndices: [],      
            tableValues: [],      
            mapGrid: [],          
            isTableCorrect: false,
            isMapCorrect: false,
            mode: 'edit',         
            selectedIndices: new Set(),
            groups: [],
            nextColorIndex: 0,
            animState: null
        };

        // --- INIT & RESET ---
        function resetApp() {
            state.vars = parseInt(document.getElementById('varCountSelect').value);
            state.solveMode = document.getElementById('solveModeSelect').value;
            generateNewTask();
        }

        function generateNewTask() {
            const totalCells = Math.pow(2, state.vars);
            state.taskIndices = [];
            for(let i=0; i<totalCells; i++) { if(Math.random() > 0.5) state.taskIndices.push(i); }
            state.taskIndices.sort((a,b) => a-b);
            
            updateTaskUI();
            resetDataAndUI();
        }
        
        function applyCustomIndices() {
            const input = document.getElementById('customIndices').value;
            const indices = input.split(',')
                .map(s => parseInt(s.trim()))
                .filter(n => !isNaN(n) && n >= 0 && n < Math.pow(2, state.vars));
            
            if (indices.length === 0 && input.trim() !== "") {
                alert("≈Ω√°dn√© platn√© indexy.");
                return;
            }
            
            state.taskIndices = [...new Set(indices)].sort((a,b) => a-b);
            updateTaskUI();
            resetDataAndUI();
        }
        
        function updateTaskUI() {
            document.getElementById('taskIndices').innerText = state.taskIndices.join(', ');
            document.getElementById('taskDesc').innerText = `Vypl≈à sloupec Y. ${state.solveMode === 'minterm' ? 'Jedniƒçku' : 'Nulu'} dej tam, kde index odpov√≠d√° zad√°n√≠.`;
        }
        
        function resetDataAndUI() {
            const totalCells = Math.pow(2, state.vars);
            state.tableValues = new Array(totalCells).fill(0);
            state.mapGrid = new Array(totalCells).fill(0); 
            state.groups = [];
            state.selectedIndices.clear();
            state.isTableCorrect = false;
            state.isMapCorrect = false;
            state.nextColorIndex = 0;
            stopAnimation();

            document.getElementById('mapPanel').style.opacity = '0.5';
            document.getElementById('mapPanel').style.pointerEvents = 'none';
            document.getElementById('solvePanel').style.opacity = '0.5';
            document.getElementById('solvePanel').style.pointerEvents = 'none';
            document.getElementById('btnCheckTable').disabled = false;
            document.getElementById('btnCheckMap').disabled = false;
            
            hideMsgs();
            document.getElementById('groupsList').innerHTML = '';
            document.getElementById('finalEquation').innerText = 'Y = ...';
            
            renderTruthTable();
            renderMap();
        }
        
        // --- SKIP FEATURE ---
        function skipToSolver() {
            const totalCells = Math.pow(2, state.vars);
            const targetVal = state.solveMode === 'minterm' ? 1 : 0;
            const otherVal = targetVal === 1 ? 0 : 1;
            
            // Auto-fill Table & Map
            for(let i=0; i<totalCells; i++) {
                const val = state.taskIndices.includes(i) ? targetVal : otherVal;
                state.tableValues[i] = val;
                state.mapGrid[i] = val;
            }
            
            // Set flags
            state.isTableCorrect = true;
            state.isMapCorrect = true;
            
            // UI Updates
            renderTruthTable();
            renderMap();
            
            document.getElementById('mapPanel').style.opacity = '1';
            document.getElementById('mapPanel').style.pointerEvents = 'auto';
            document.getElementById('btnCheckTable').disabled = true;
            document.getElementById('btnCheckMap').disabled = true;
            document.getElementById('solvePanel').style.opacity = '1';
            document.getElementById('solvePanel').style.pointerEvents = 'auto';
            
            const targetStr = state.solveMode === 'minterm' ? 'jedniƒçky' : 'nuly';
            document.getElementById('solveInst').innerText = `1. Oznaƒç ${targetStr}. 2. Vytvo≈ô skupinu. 3. Urƒçi promƒõnn√©.`;
            
            // Hide messages
            hideMsgs();
        }

        // --- STEP 1: TRUTH TABLE ---
        function renderTruthTable() {
            const table = document.getElementById('truthTable');
            table.innerHTML = '';
            
            const thead = document.createElement('tr');
            const vars = getVarNames();
            const thHint = document.createElement('th'); thHint.innerText = 'üîç'; thead.appendChild(thHint);
            
            vars.forEach(v => {
                const th = document.createElement('th'); th.innerText = v; thead.appendChild(th);
            });
            const thY = document.createElement('th'); thY.innerText = 'Y'; thead.appendChild(thY);
            table.appendChild(thead);

            const totalRows = Math.pow(2, state.vars);
            for(let i=0; i<totalRows; i++) {
                const tr = document.createElement('tr');
                tr.id = `row-${i}`;
                
                const tdEye = document.createElement('td');
                const btn = document.createElement('button');
                btn.className = 'eye-btn';
                btn.innerText = 'üëÅÔ∏è';
                btn.title = "Uk√°zat v mapƒõ";
                btn.onclick = () => startAnimation(i);
                tdEye.appendChild(btn);
                tr.appendChild(tdEye);

                for(let bit=state.vars-1; bit>=0; bit--) {
                    const td = document.createElement('td');
                    td.innerText = (i >> bit) & 1;
                    tr.appendChild(td);
                }
                
                const tdY = document.createElement('td');
                tdY.className = 'output-cell';
                tdY.innerText = state.tableValues[i];
                tdY.onclick = () => {
                    if(state.isTableCorrect) return; 
                    state.tableValues[i] = state.tableValues[i] === 1 ? 0 : 1;
                    tdY.innerText = state.tableValues[i];
                    updateTableCellColor(tdY, state.tableValues[i]);
                };
                updateTableCellColor(tdY, state.tableValues[i]);
                tr.appendChild(tdY);

                table.appendChild(tr);
            }
        }

        function updateTableCellColor(cell, val) {
            cell.className = 'output-cell ' + (val === 1 ? 'is-1' : 'is-0');
        }

        function checkTable() {
            let correct = true;
            const targetVal = state.solveMode === 'minterm' ? 1 : 0;
            const otherVal = targetVal === 1 ? 0 : 1;

            for(let i=0; i<state.tableValues.length; i++) {
                const isTarget = state.taskIndices.includes(i);
                const userVal = state.tableValues[i];
                if (isTarget && userVal !== targetVal) correct = false;
                if (!isTarget && userVal !== otherVal) correct = false;
            }

            const msg = document.getElementById('tableMsg');
            msg.style.display = 'block';
            if (correct) {
                msg.className = 'status-msg success-text';
                msg.innerText = "Spr√°vnƒõ! Nyn√≠ p≈ôenes hodnoty do mapy.";
                state.isTableCorrect = true;
                
                document.getElementById('mapPanel').style.opacity = '1';
                document.getElementById('mapPanel').style.pointerEvents = 'auto';
                document.getElementById('btnCheckTable').disabled = true;
            } else {
                msg.className = 'status-msg error-text';
                msg.innerText = "Chyba v tabulce. Zkontroluj zad√°n√≠.";
            }
        }

        // --- INTERACTIVE ANIMATION ---
        
        function startAnimation(rowIndex) {
            if (state.animState) stopAnimation();
            
            document.querySelectorAll('tr').forEach(tr => tr.classList.remove('active-row'));
            document.getElementById(`row-${rowIndex}`).classList.add('active-row');

            document.getElementById('animPanel').style.display = 'block';
            
            // RESET BUTTON CLICK HANDLER (FIX FOR BUG)
            const btn = document.getElementById('animNextBtn');
            btn.innerText = "Zaƒç√≠t eliminaci";
            btn.onclick = nextAnimStep;

            document.getElementById('animText').innerText = `Hled√°me pol√≠ƒçko pro ≈ô√°dek ${rowIndex} (bin√°rnƒõ ${rowIndex.toString(2).padStart(state.vars, '0')}).`;

            // Initial visual state: Dim EVERYTHING
            const cells = document.querySelectorAll('table.kmap td[data-index]');
            cells.forEach(c => {
                c.className = ''; 
                c.classList.add('dimmed');
            });

            // Initialize candidates: All cells are candidates
            const candidates = new Set();
            const total = Math.pow(2, state.vars);
            for(let i=0; i<total; i++) candidates.add(i);

            state.animState = {
                rowIndex: rowIndex,
                step: 0,
                phase: 'SHOW',
                candidates: candidates
            };
        }

        function nextAnimStep() {
            if (!state.animState) return;
            const { rowIndex, step, phase, candidates } = state.animState;
            const varNames = getVarNames();
            const getBit = (idx, varPos) => (idx >> (state.vars - 1 - varPos)) & 1;
            const cells = document.querySelectorAll('table.kmap td[data-index]');
            const txt = document.getElementById('animText');
            const btn = document.getElementById('animNextBtn');

            if (step >= state.vars) {
                // Final State
                const targetCell = document.querySelector(`td[data-index="${rowIndex}"]`);
                if(targetCell) {
                    targetCell.className = ''; 
                    targetCell.classList.add('target-pulse');
                }
                txt.innerHTML = `<span style="color:#66bb6a; font-weight:bold;">C√≠l nalezen!</span> Zde pat≈ô√≠ hodnota z tabulky.`;
                btn.innerText = "Hotovo";
                btn.onclick = stopAnimation;
                return;
            }

            const varName = varNames[step];
            const requiredBit = getBit(rowIndex, step); 

            if (phase === 'SHOW') {
                txt.innerHTML = `Krok ${step+1}: Podm√≠nka <b>${varName} = ${requiredBit}</b>.<br><span style="color:#66bb6a">Zelen√° = Spl≈àuje</span>, <span style="color:#ef5350">ƒåerven√° = Nespl≈àuje (Vylouƒçit)</span>.`;
                
                cells.forEach(c => {
                    const idx = parseInt(c.dataset.index);
                    
                    // Only interact with active candidates
                    if (!candidates.has(idx)) return;

                    c.classList.remove('dimmed'); // Highlight to show red/green status
                    
                    const cellBit = getBit(idx, step);
                    if (cellBit === requiredBit) {
                        c.classList.add('zone-valid');
                    } else {
                        c.classList.add('zone-invalid');
                    }
                });
                
                btn.innerText = "Eliminovat ƒçervenou";
                state.animState.phase = 'ELIMINATE';

            } else {
                // ELIMINATE PHASE
                txt.innerHTML = `Eliminov√°na oblast, kde <b>${varName} != ${requiredBit}</b>.`;
                
                cells.forEach(c => {
                    const idx = parseInt(c.dataset.index);
                    if (!candidates.has(idx)) return;

                    if (c.classList.contains('zone-invalid')) {
                        // Eliminate
                        c.classList.remove('zone-invalid');
                        c.classList.add('dimmed');
                        candidates.delete(idx); // Remove from logical candidates
                    }
                    if (c.classList.contains('zone-valid')) {
                        // Keep (strip color, keep undimmed)
                        c.classList.remove('zone-valid');
                    }
                });
                
                state.animState.step++;
                state.animState.phase = 'SHOW';
                btn.innerText = "Dal≈°√≠ podm√≠nka";
            }
        }

        function stopAnimation() {
            state.animState = null;
            document.getElementById('animPanel').style.display = 'none';
            document.querySelectorAll('tr').forEach(tr => tr.classList.remove('active-row'));
            
            // Reset map visual completely
            renderMap();
        }

        // --- MAP RENDERING ---

        function renderMap() {
            const wrapper = document.getElementById('mapContainer');
            wrapper.innerHTML = '';
            
            let rowsArr, colsArr;
            if (state.vars === 2) { rowsArr=grayCodes[1]; colsArr=grayCodes[1]; }
            else if (state.vars === 3) { rowsArr=grayCodes[1]; colsArr=grayCodes[2]; }
            else { rowsArr=grayCodes[2]; colsArr=grayCodes[2]; }

            const table = document.createElement('table');
            table.className = 'kmap';
            
            const colVarShift = Math.ceil(state.vars / 2);

            for (let r = 0; r < rowsArr.length; r++) {
                const tr = document.createElement('tr');
                for (let c = 0; c < colsArr.length; c++) {
                    const td = document.createElement('td');
                    const rowGray = rowsArr[r];
                    const colGray = colsArr[c];
                    const index = (rowGray << colVarShift) | colGray;

                    td.dataset.index = index;
                    td.innerText = state.mapGrid[index];
                    td.dataset.val = state.mapGrid[index];
                    td.onclick = () => handleMapClick(index);

                    if (state.selectedIndices.has(index)) td.classList.add('selected');
                    
                    const participatingGroups = state.groups.filter(g => g.indices.includes(index));
                    participatingGroups.forEach((group, i) => {
                        const ind = document.createElement('div');
                        ind.className = 'group-indicator';
                        const offset = (i * 4) + 2;
                        ind.style.inset = `${offset}px`;
                        ind.style.border = `2px solid ${group.color}`;
                        td.appendChild(ind);
                    });

                    tr.appendChild(td);
                }
                table.appendChild(tr);
            }
            wrapper.appendChild(table);
            drawColemanLines(wrapper);
        }

        function handleMapClick(index) {
            if (!state.isTableCorrect) return; 
            if (state.animState) return; 

            if (!state.isMapCorrect) {
                state.mapGrid[index] = state.mapGrid[index] === 1 ? 0 : 1;
                renderMap();
            } else {
                const targetVal = state.solveMode === 'minterm' ? 1 : 0;
                if (state.mapGrid[index] !== targetVal) return;
                
                if (state.selectedIndices.has(index)) state.selectedIndices.delete(index);
                else state.selectedIndices.add(index);
                renderMap();
            }
        }

        function checkMapAndUnlock() {
            let correct = true;
            for(let i=0; i<state.mapGrid.length; i++) {
                if(state.mapGrid[i] !== state.tableValues[i]) correct = false;
            }

            const msg = document.getElementById('mapMsg');
            msg.style.display = 'block';
            if (correct) {
                msg.className = 'status-msg success-text';
                msg.innerText = "Spr√°vnƒõ! Odemyk√°m minimalizaci.";
                state.isMapCorrect = true;
                
                document.getElementById('solvePanel').style.opacity = '1';
                document.getElementById('solvePanel').style.pointerEvents = 'auto';
                document.getElementById('btnCheckMap').disabled = true;
                
                const target = state.solveMode === 'minterm' ? 'jedniƒçky' : 'nuly';
                document.getElementById('solveInst').innerText = `1. Oznaƒç ${target}. 2. Vytvo≈ô skupinu. 3. Urƒçi promƒõnn√©.`;

            } else {
                msg.className = 'status-msg error-text';
                msg.innerText = "Mapa neodpov√≠d√° tabulce! Pou≈æij ikonu oka v tabulce pro n√°povƒõdu.";
            }
        }

        // --- STEP 3: SOLVER ---
        function createGroupFromSelection() {
            const indices = Array.from(state.selectedIndices).sort((a,b)=>a-b);
            if (indices.length === 0) return;
            
            if (!isPowerOf2(indices.length)) { showErr("Neplatn√° velikost."); return; }
            if (!isValidShape(indices)) { showErr("Neplatn√Ω tvar."); return; }
            if (state.groups.some(g => arraysEqual(g.indices, indices))) { showErr("Duplicitn√≠ skupina."); return; }
            if (!isGroupMaximal(indices)) { showErr("Skupina nen√≠ maxim√°ln√≠."); return; }

            const covered = new Set();
            state.groups.forEach(g => g.indices.forEach(i => covered.add(i)));
            if (!indices.some(i => !covered.has(i)) && state.groups.length > 0) {
                 showErr("Zbyteƒçn√° skupina."); return;
            }

            const group = {
                id: Date.now(),
                indices: indices,
                color: colors[state.nextColorIndex % colors.length],
                vars: {}
            };
            state.nextColorIndex++;
            getVarNames().forEach(v => group.vars[v] = 0);
            
            state.groups.push(group);
            
            const redundantIds = [];
            state.groups.forEach((oldG, idx) => {
                 if (oldG.id === group.id) return;
                 const others = state.groups.filter(g => g.id !== oldG.id);
                 const othersCover = new Set();
                 others.forEach(o => o.indices.forEach(i => othersCover.add(i)));
                 if (oldG.indices.every(i => othersCover.has(i))) redundantIds.push(idx + 1);
            });
            
            if (redundantIds.length > 0) showErr(`Upozornƒõn√≠: Skupina ${redundantIds.join(', ')} je nyn√≠ zbyteƒçn√°.`);

            state.selectedIndices.clear();
            renderMap();
            renderGroupsList();
            updateEq();
        }

        function renderGroupsList() {
            const ul = document.getElementById('groupsList');
            ul.innerHTML = '';
            state.groups.forEach((g, idx) => {
                const li = document.createElement('li');
                li.className = 'group-item';
                li.style.borderLeftColor = g.color;
                
                let btns = '';
                getVarNames().forEach(v => {
                    const s = g.vars[v];
                    let css = '', txt = '-';
                    if (s===1) { css='s-1'; txt=v; }
                    if (s===2) { css='s-0'; txt='!'+v; }
                    btns += `<div class="var-btn ${css}" onclick="toggleVar(${g.id}, '${v}')"><span class="l">${v}</span><span class="v">${txt}</span></div>`;
                });

                li.innerHTML = `
                    <div style="display:flex; justify-content:space-between; margin-bottom:5px;">
                        <strong style="color:${g.color}">Skupina ${idx+1}</strong>
                        <button class="secondary" style="padding:2px 8px; font-size:0.7rem;" onclick="removeGroup(${g.id})">SMAZAT</button>
                    </div>
                    <div class="var-toggles">${btns}</div>
                `;
                ul.appendChild(li);
            });
        }

        function toggleVar(gid, v) {
            const g = state.groups.find(x => x.id === gid);
            if(g) {
                g.vars[v] = (g.vars[v] + 1) % 3;
                renderGroupsList();
                updateEq();
            }
        }
        
        function removeGroup(gid) {
            state.groups = state.groups.filter(x => x.id !== gid);
            renderMap();
            renderGroupsList();
            updateEq();
        }

        function updateEq() {
            const terms = state.groups.map(g => {
                const parts = [];
                getVarNames().forEach(v => {
                    if (g.vars[v]===1) parts.push(v);
                    if (g.vars[v]===2) parts.push("!"+v);
                });
                if (parts.length===0) return state.solveMode === 'minterm' ? "1" : "0";
                if (state.solveMode === 'minterm') return parts.join("");
                else return "(" + parts.join("+") + ")";
            });
            const joiner = state.solveMode === 'minterm' ? " + " : "";
            document.getElementById('finalEquation').innerText = "Y = " + (terms.length ? terms.join(joiner) : "...");
        }

        function checkFinalResult() {
            const status = document.getElementById('finalStatus');
            status.style.display = 'block';
            
            const targetVal = state.solveMode === 'minterm' ? 1 : 0;
            const targets = [];
            state.mapGrid.forEach((v,i) => { if(v===targetVal) targets.push(i); });
            const covered = new Set();
            state.groups.forEach(g => g.indices.forEach(i => covered.add(i)));
            
            const missing = targets.filter(i => !covered.has(i));
            if (missing.length > 0) {
                status.className = 'status-msg error-text';
                status.innerText = `Chyba pokryt√≠.`;
                return;
            }

            const redundantIds = [];
            state.groups.forEach((oldG, idx) => {
                 const others = state.groups.filter(g => g.id !== oldG.id);
                 const othersCover = new Set();
                 others.forEach(o => o.indices.forEach(i => othersCover.add(i)));
                 if (oldG.indices.every(i => othersCover.has(i))) redundantIds.push(idx + 1);
            });
            if (redundantIds.length > 0) {
                status.className = 'status-msg error-text';
                status.innerText = `Chyba: Zbyteƒçn√© skupiny (${redundantIds.join(', ')}).`;
                return;
            }

            let err = null;
            state.groups.forEach((g, idx) => {
                if (err) return;
                const logic = getLogic(g.indices); 
                const user = g.vars;
                
                const userSelected = getVarNames().filter(v => user[v] !== 0);
                const logicSelected = Object.keys(logic);
                
                if (!arraysEqual(userSelected.sort(), logicSelected.sort())) {
                    err = `Skupina ${idx+1}: ≈†patnƒõ zvolen√© promƒõnn√©.`; return;
                }

                logicSelected.forEach(v => {
                    const realBit = logic[v]; 
                    const userState = user[v]; 
                    let correctState;
                    if (state.solveMode === 'minterm') correctState = (realBit === 1) ? 1 : 2;
                    else correctState = (realBit === 0) ? 1 : 2; 
                    if (userState !== correctState) err = `Skupina ${idx+1}: Chyba v negaci (${v}).`;
                });
            });

            if (err) {
                status.className = 'status-msg error-text';
                status.innerText = err;
            } else {
                status.className = 'status-msg success-text';
                status.innerText = "V√ùBORNƒö! V≈°e je spr√°vnƒõ.";
            }
        }
        
        function showSmartHint() {
            const box = document.getElementById('hintBox');
            box.style.display = 'block';
            const targetVal = state.solveMode === 'minterm' ? 1 : 0;
            const targets = [];
            state.mapGrid.forEach((v,i) => { if(v===targetVal) targets.push(i); });
            const covered = new Set();
            state.groups.forEach(g => g.indices.forEach(i => covered.add(i)));
            const missing = targets.find(i => !covered.has(i));
            
            if (missing !== undefined) {
                 box.innerText = `Bu≈àka (index ${missing}) nen√≠ pokryta.`;
                 const cell = document.querySelector(`td[data-index="${missing}"]`);
                 if(cell) { cell.classList.add('target-pulse'); setTimeout(()=>cell.classList.remove('target-pulse'), 2000); }
                 return;
            }
            box.innerText = "V≈°e pokryto. Zkontroluj promƒõnn√©.";
        }

        // --- UTILS ---
        function getVarNames() {
            if (state.vars === 2) return ['A','B'];
            if (state.vars === 3) return ['A','B','C'];
            return ['A','B','C','D'];
        }
        function isPowerOf2(n) { return (n & (n-1)) === 0; }
        function arraysEqual(a, b) { return a.length === b.length && a.every((v, i) => v === b[i]); }
        function showErr(msg) { const el = document.getElementById('groupError'); el.innerText = msg; el.style.display='block'; setTimeout(() => el.style.display='none', 4000); }
        function hideMsgs() {
            document.getElementById('tableMsg').style.display='none';
            document.getElementById('mapMsg').style.display='none';
            document.getElementById('finalStatus').style.display='none';
        }
        
        function isValidShape(indices) {
            if (indices.length===1) return true;
            let and=indices[0], or=indices[0];
            indices.forEach(i => { and&=i; or|=i; });
            const diff = and ^ or;
            let bits = 0; let t=diff; while(t>0){ if(t&1)bits++; t>>=1; }
            if (bits !== Math.log2(indices.length)) return false;
            const constant = indices[0] & (~diff);
            return indices.every(i => (i & (~diff)) === constant);
        }
        
        function isGroupMaximal(indices) {
            const targetVal = state.solveMode === 'minterm' ? 1 : 0;
            let and=indices[0], or=indices[0];
            indices.forEach(i => { and&=i; or|=i; });
            const diff = and ^ or;
            const constMask = ~diff;
            for(let i=0; i<state.vars; i++) {
                const bit = 1 << i;
                if ((constMask & bit) !== 0) {
                    const partner = indices.map(idx => idx ^ bit);
                    if (partner.every(idx => state.mapGrid[idx] === targetVal)) return false;
                }
            }
            return true;
        }

        function getLogic(indices) {
            let and=indices[0], or=indices[0];
            indices.forEach(i => { and&=i; or|=i; });
            const diff = and ^ or;
            const logic = {};
            const names = getVarNames();
            for(let i=0; i<state.vars; i++) {
                const bit = 1 << (state.vars - 1 - i); 
                if ((diff & bit) === 0) {
                    const val = (indices[0] & bit) !== 0 ? 1 : 0;
                    logic[names[i]] = val;
                }
            }
            return logic;
        }

        function drawColemanLines(wrapper) {
            const cellSize = 60; // Same as CSS
            const addLine = (label, isVert, start, len, off) => {
                const l = document.createElement('div');
                l.className = `var-line ${isVert?'line-vertical':'line-horizontal'}`;
                const s = document.createElement('span'); s.className='line-label'; s.innerText=label; l.appendChild(s);
                const mg=5; const sp=15;
                if (isVert) {
                    l.style.height=(len*cellSize)+'px'; 
                    // 40 padding top. 
                    l.style.top=(start*cellSize)+40+'px';
                    // 40 padding left. Move left.
                    l.style.left= (40 - mg - (off*sp)) + 'px'; 
                } else {
                    l.style.width=(len*cellSize)+'px'; 
                    l.style.left=(start*cellSize)+40+'px'; 
                    // Move top.
                    l.style.top= (40 - mg - (off*sp)) + 'px';
                }
                wrapper.appendChild(l);
            };
            
            // Standard positioning relative to padding
            if(state.vars===2) { addLine('A',1,1,1,1); addLine('B',0,1,1,1); }
            else if(state.vars===3) { addLine('A',1,1,1,1); addLine('B',0,2,2,2); addLine('C',0,1,2,1); }
            else { addLine('A',1,2,2,2); addLine('B',1,1,2,1); addLine('C',0,2,2,2); addLine('D',0,1,2,1); }
        }

        window.onload = resetApp;
    </script>
</body>
</html>
